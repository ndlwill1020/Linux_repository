执行IO操作指的是：把数据从内核拷贝到用户空间的过程


eg：一个套接字的读操作有两个阶段
1.等待数据准备好（等待数据到达网络，然后被拷贝到套接字的缓冲区）
2.从内核拷贝数据到进程缓冲区

1.阻塞式IO模型 阻塞于读写操作
read()时，如果套接字缓冲区收到的数据达到了“低水位标记”（就是有数据可用，默认低水位标记为1字节），无数据可用时回阻塞在read()调用中，直到
收到的数据达到缓冲区的低水位标记要求的数量或套接字被关闭，read()返回之前，会把套节字缓冲区的可用数据复制到应用程序缓冲区

应用程序      					内核
	－>系统调用切换至内核   		数据未准备好
								等待
	<-数据从内核复制到应用程序		数据准备好


可能阻塞套接字的系统调用：
read() readv() recv() recvfrom()
write() writev() send() sendto()
accept()
conncet()

缺点：
不适合高并发的开发


2.非阻塞式IO模型 阻塞于拷贝数据的阶段
当请求的IO操作不能立即完成时，不阻塞，一开始read()返回－1，内核返回错误并设置errno为EWOULDBLOCK或EAGIN，
再read(),数据准备好，拷贝到应用缓冲区
应用程序不断的查询内核，看某操作是否准备好，这个过程叫轮询，这对CPU时间是极大的浪费

3.IO复用模型  阻塞与I/O复用系统调用
可以调用select()或poll

阻塞在select()调用上,等待套接字可读 （数据未准备－－－－数据准备好），当select()返回套接字可读条件时，调用read()
它与阻塞式IO模型比较没有明显优越，但他的好处是可以同时等待多个文件描述符


关注的消息：套接字是否可读可写
处理消息：对套接字读写

4.信号驱动IO  没有阻塞阶段
进程不会被阻塞，当数据就绪可读时，捕获信号，收到信号后由主程序调用read()读取数据，或在信号句柄中调用read()读取数据后通知主程序处理

5.异步IO模型  没有阻塞阶段
我们告诉内核开始IO操作，并在整个操作完成后（包括从内核复制数据到应用程序缓冲区）通知我们

同步IO：导致发出请求的进程被阻塞直到IO操作完成  （前面4种是同步IO，它们都需要做实际的IO操作并有可能被阻塞）
异步IO：不导致发出请求的进程被阻塞


IO模型的组合使用
		阻塞 						非阻塞
同步 	read/write      			read/write(O_NONBLOCK)
异步     IO复用（select()/epoll())    AIO系列函数
