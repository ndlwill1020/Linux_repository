我的理解IO复用：如果一个或多个IO条件满足时，我们会得到通知＃＃＃＃＃

IO多路复用之select系统调用:
比如服务器端发送消息之后就等客户端发送消息了，没有接受到客户端的消息之前服务器端是没有办法发送消息的。使用select可以解决这个问题

使用select()时，我们通知内核我们对哪些文件描述符感兴趣（读，写或异常条件）以及等待多少时间，select()会替我们测试文件描述符是否准备好

select这个系统调用，是一种多路复用IO方案，可以同时对多个文件描述符进行监控，从而知道哪些文件描述符可读，可写或者出错，不过select方法是阻塞的，可以设定超时时间。 select使用的步骤如下:
1.创建一个fd_set变量（fd_set实为包含了一个整数数组的结构体），用来存放所有的待检查的文件描述符
2.清空fd_set变量，并将需要检查的所有文件描述符加入fd_set
3.调用select。若返回-1，则说明出错;返回0,则说明超时，返回正数，则为发生状态变化的文件描述符的个数
4.若select返回大于0,则依次查看哪些文件描述符变的可读，并对它们进行处理
5.返回步骤2，开始新一轮的检测



------------------------------------------
#include <sys/select.h>
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>

struct timeval{
    long tv_sec;   //seconds
    long tv_usec;  //microseconds微妙  百万分之1秒
};
struct timeval* timeout是select的超时时间，要等待的时间是秒数和微秒数之和
如果在超时之前，select()成功返回，它将返回一个正整数，表示集合中有几个文件描述符已经准备好（当我们关心的1个文件描述符的读和写2个状态，如果都准备好返回2）
它可以使select处于三种状态：
第一，若将NULL以形参传入，即不传入时间结构，就是将select置于阻塞状态，一定等到监视文件描述符集合中某个文件描述符发生变化为止；(永远等待下去：仅在有一个描述字准备好I/O（数据准备好）时才返回)
第二，若将时间值设为0秒0毫秒，就变成一个纯粹的非阻塞函数，不管文件描述符是否有变化，都立刻返回继续执行，文件无变化返回0，有变化返回一个正值；(根本不等待：检查描述字后立即返回，这称为轮询)
第三，timeout的值大于0，这就是等待的超时时间，即 select在timeout时间内阻塞，超时时间之内有事件到来就返回了(等待一段固定时间：在有一个描述字准备好I/O时返回，但不超过超时时间)


//返回值：就绪描述符的数目（正数），超时返回0，出错返回-1并设置errno
int select(int maxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,struct timeval *timeout);//可以监听多个文件描述符

/*参数列表
int maxfdp是一个整数值，指定待测试的描述字个数,它的值是待测试的最大描述字加1（因此把该参数命名为maxfdp1），描述字0、1、2...maxfdp1-1均将被测试。因为文件描述符是从0开始的 #####
　　
fd_set *readfds是指向fd_set结构的指针，这个集合中应该包括文件描述符，我们是要监视这些文件描述符的读变化的，即我们关心是否可以从这些文件中读取数据了，如果这个集合中有一个文件可读，select就会返回一个大于0的值，表示有文件可读，如果没有可读的文件，则根据timeout参数再判断是否超时，若超出timeout的时间，select返回0，若发生错误返回负值。可以传入NULL值，表示不关心任何文件的读变化。 
　　
fd_set *writefds是指向fd_set结构的指针，这个集合中应该包括文件描述符，我们是要监视这些文件描述符的写变化的，即我们关心是否可以向这些文件中写入数据了，如果这个集合中有一个文件可写，select就会返回一个大于0的值，表示有文件可写，如果没有可写的文件，则根据timeout参数再判断是否超时，若超出timeout的时间，select返回0，若发生错误返回负值。可以传入NULL值，表示不关心任何文件的写变化。 
　　
fd_set *errorfds同上面两个参数的意图，用来监视文件错误异常。 
*/


FD_ZERO(fd_set *set);//把set指向的文件描述符集合（即fd_set）对应的位全部初始化为0
FD_SET(int fd, fd_set *set);//将set指向的文件描述符集合中对应文件描述符fd的位 置为1
FD_CLR(int fd, fd_set *set);//将set指向的文件描述符集合中对应文件描述符fd的位 置为0
FD_ISSET(int fd, fd_set *set);//检测set指向的文件描述符集合中对应文件描述符fd的位是否被置为1



第一，struct fd_set可以理解为一个集合，这个集合中存放的是文件描述符(file descriptor)，即文件句柄，这可以是我们所说的普通意义的文件，当然Unix下任何设备、管道、FIFO等都是文件形式，全部包括在内，所以毫无疑问一个socket就是一个文件，socket句柄就是一个文件描述符。fd_set集合可以通过一些宏由人为来操作，比如清空集合 FD_ZERO(fd_set *)，将一个给定的文件描述符加入集合之中FD_SET(int ,fd_set *)，将一个给定的文件描述符从集合中删除FD_CLR(int ,fd_set*)，检查集合中指定的文件描述符是否可以读写FD_ISSET(int ,fd_set* )



select()返回时将修改由指针readset，writeset和exceptset所指的文件描述符集合
用FD_ISSET来测试fd_set中的文件描述符（文件描述符集合中没有准备好的文件描述符相对应的位被置0，FD_ISSET返回0；准备好的文件描述符相对应的位被置1，FD_ISSET返回1）
每次调用select()都必须重新使用FD_SET()设置文件描述符集合中关心的描述符 (因为select()返回时，会将那些没有准备好的描述符的位置为0)

常见问题：
当套接字关闭或出错时，select()返回套接字可读可写，所以要检查read()和write()的返回值判断是否连接已经关闭


－－－－－－－－－－－－－－－－－－－－－－
socket可读的条件：
socket中字节大于低水位   //socket内核接收缓冲区的字节数大于等于低水位
socket对方关闭连接  //socket读取0
监听socket上有新的连接
socket上有待处理的错误  //getsockopt来读取或清除错误

socket可写的条件：
socket中发送缓冲区字节大于低水位
socket对方写操作关闭
socket上使用非阻塞connect连接成功或者失败后
socket上有未处理的错误

select可以处理带外数据

select缺点：
单个进程可监视的fd数量有限制
对socket采用轮询的方法
需要维护一个用来存放大量fd的数据结构


